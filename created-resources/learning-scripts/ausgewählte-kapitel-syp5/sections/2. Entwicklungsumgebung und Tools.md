# Entwicklungsumgebung und Tools

Stellen Sie sich vor, Sie bauen ein komplexes GebÃ¤ude: Ohne die richtigen Werkzeuge, PlÃ¤ne und eine koordinierte Zusammenarbeit im Team wÃ¤re das Projekt zum Scheitern verurteilt. Genauso verhÃ¤lt es sich in der Softwareentwicklung â€“ die Wahl und der gezielte Einsatz von Entwicklungsumgebungen und Tools sind entscheidend fÃ¼r den Erfolg moderner Softwareprojekte.

In diesem Kapitel lernen Sie die wichtigsten Werkzeuge und Methoden kennen, die den Entwicklungsprozess effizient, sicher und nachvollziehbar machen. Dazu gehÃ¶ren Versionsverwaltungssysteme wie Git, Build- und Dependency-Management-Tools, Continuous Integration (CI) sowie bewÃ¤hrte Workflows fÃ¼r die Zusammenarbeit im Team. Sie erfahren, wie diese Tools ineinandergreifen, typische Fehler vermeiden helfen und die QualitÃ¤t der Software nachhaltig sichern.

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
Die richtige Kombination aus Tools und Prozessen ermÃ¶glicht nicht nur eine reibungslose Entwicklung, sondern auch eine schnelle Anpassung an neue Anforderungen und eine kontinuierliche Verbesserung der Software.

***
Quellen

- [Git SCM Documentation](https://git-scm.com/doc)
- [Continuous Integration â€“ Martin Fowler](https://martinfowler.com/articles/continuousIntegration.html)
- [Apache Maven](https://maven.apache.org/)
***

### Versionsverwaltung mit Git

**Git** ist ein **verteiltes Versionsverwaltungssystem (VCS â€“ Version Control System)**, das zur Nachverfolgung von Ã„nderungen an Dateien â€“ insbesondere Quellcode â€“ dient.
Es wurde 2005 von **Linus Torvalds** (dem Entwickler des Linux-Kernels) entwickelt und ist heute der **Standard in der Softwareentwicklung**.

**ðŸ”§ Hauptzweck:**

* Nachverfolgung aller Ã„nderungen an Dateien
* Zusammenarbeit mehrerer Entwickler:innen
* Wiederherstellen frÃ¼herer ZustÃ¤nde
* Paralleles Arbeiten an verschiedenen Funktionen

#### Repositories

Das Repository stellt das Fundament der Versionsverwaltung dar. Ein **Repository** (kurz: *Repo*) ist das **zentrale Projektarchiv**, in dem Git alle Versionen und Metadaten eines Projekts speichert.

**ðŸ“¦ Arten von Repositories:**

| Typ                    | Beschreibung                                                                  | Beispiel                                |
| ---------------------- | ----------------------------------------------------------------------------- | --------------------------------------- |
| **Lokales Repository** | Auf dem eigenen Rechner gespeichert. EnthÃ¤lt vollstÃ¤ndige Versionsgeschichte. | `.git`-Ordner im Projektverzeichnis     |
| **Remote Repository**  | Zentrale Version des Projekts auf einem Server (z. B. GitHub, GitLab).        | `https://github.com/Schule/Projekt.git` |


**âš™ï¸ Grundstruktur des Git-Repostroy**

Ein Git-Repository besteht aus:

* **Arbeitsverzeichnis (Working Directory)** â†’ enthÃ¤lt aktuelle Dateien
* **Staging Area (Index)** â†’ Bereich, in dem Ã„nderungen vorbereitet werden
* **Repository (.git)** â†’ speichert alle Commits und Metadaten dauerhaft

```
Working Directory â†’ Staging Area â†’ Repository
```

### ðŸ’¡ Beispiel:

```bash
git init                 # Neues lokales Repository erstellen
git remote add origin https://github.com/schule/projekt.git  # Remote-Repo hinzufÃ¼gen
```

---

#### ðŸ§± `Commit` â€“ Versionierung der Ã„nderungen

Ein **Commit** ist eine **gespeicherte Momentaufnahme (Snapshot)** des Projekts zu einem bestimmten Zeitpunkt.
Jeder Commit enthÃ¤lt:

* den Autor
* das Datum
* eine eindeutige **Commit-ID (Hash)**
* eine **Commit-Nachricht**
* die Ã„nderungen (Delta) zum vorherigen Zustand

**ðŸ”„ Commit-Workflow:**

1. Ã„nderungen im Arbeitsverzeichnis durchfÃ¼hren
2. Mit `git add` zur Staging Area hinzufÃ¼gen
3. Mit `git commit` dauerhaft speichern

```bash
git add main.java
git commit -m "Implementiere Login-Funktion"
```

**ðŸ§© Beispielhafter Commit-Verlauf:**

| Commit-ID | Beschreibung                       | Datum      | Autor |
| --------- | ---------------------------------- | ---------- | ----- |
| a1b2c3d   | Projektinitialisierung             | 12.10.2025 | Anna  |
| d4e5f6g   | Login-Funktion implementiert       | 13.10.2025 | Max   |
| h7i8j9k   | Bugfix: PasswortprÃ¼fung korrigiert | 14.10.2025 | Max   |


> <span style="font-size: 1.5em">:bulb:</span>Jeder Commit ist ein â€žSpeicherpunktâ€œ in der Projektgeschichte â€“ man kann jederzeit darauf zurÃ¼ckspringen oder vergleichen.

#### ðŸŒ¿ `Branch` â€“ paralleler Entwicklungsstrang

Ein **Branch (Zweig)** ist eine **unabhÃ¤ngige Entwicklungslinie** innerhalb des Repositories.
Mit Branches kann man neue Funktionen entwickeln, ohne den Hauptcode (meist **main** oder **master**) zu gefÃ¤hrden.

**âš™ï¸ Typischer Ablauf:**

1. Neuer Branch fÃ¼r eine Funktion erstellen
2. Ã„nderungen durchfÃ¼hren
3. Branch testen
4. Ã„nderungen wieder in den Hauptzweig **mergen**

```bash
git branch feature-login      # Neuen Branch erstellen
git checkout feature-login    # In den Branch wechseln
# ... Entwicklung ...
git checkout main             # ZurÃ¼ck zum Hauptbranch
git merge feature-login       # Ã„nderungen Ã¼bernehmen
```

**ðŸ“Š Beispielhafte Struktur:**

```
main
 â”œâ”€â”€ feature-login
 â”œâ”€â”€ feature-database
 â””â”€â”€ bugfix-session
```

> <span style="font-size: 1.5em">:bulb:</span>Branches erlauben **parallele Arbeit**, **Experimentieren** und **kontrollierte Integration** neuer Features.

---

#### ðŸ·ï¸ `Tag` â€“ markierte Version (z. B. Release)

Ein **Tag** ist eine **feste Markierung** auf einem bestimmten Commit â€“ oft fÃ¼r **wichtige Versionen** wie Releases (z. B. `v1.0.0`).
Tags verÃ¤ndern sich **nicht** und dienen als **Referenzpunkte** in der Versionshistorie.

**âš™ï¸ Beispiel:**

```bash
git tag -a v1.0.0 -m "Erste stabile Version"
git push origin v1.0.0
```

**ðŸ“¦ Verwendung:**

* Markierung von **Release-StÃ¤nden** (z. B. fÃ¼r Deployment oder Archivierung)
* Wiederherstellung einer bestimmten Version (`git checkout v1.0.0`)

> <span style="font-size: 1.5em">:bulb:</span>Tags sind â€žLesezeichenâ€œ im Projektverlauf â€“ sie helfen, wichtige Versionen leicht wiederzufinden.

#### ðŸ”— Zusammenspiel von Repository, Commits, Branches und Tags

Im folgenden wird ein typischer Ablauf skizziert:

1. Entwickler erstellt Branch â€žfeature-loginâ€œ
2. Erstellt mehrere Commits (z.B. login-Funktion implementiert, Bugfix: PasswortprÃ¼fung korrigiert)
3. Merge mit Hauptbranch
4. Version wird als `v1.0.0` getaggt

âž¡ï¸ So entsteht eine **nachvollziehbare, reproduzierbare Entwicklungs-Historie**.



```mermaid
gitGraph
	commit id: "Start Hauptbranch"
	branch feature-login
	commit id: "Login-Funktion implementiert"
	commit id: "Bugfix: PasswortprÃ¼fung korrigiert"
	checkout main
	merge feature-login tag: "v1.0.0"
```

*Das Diagramm zeigt, wie ein Feature-Branch entsteht, mehrere Commits gemacht werden, und nach dem Merge ein Tag fÃ¼r die Version gesetzt wird.*


#### ðŸ§  Typische Fehler und Best Practices

| Typische Fehler                            | Bessere Praxis                                    |
| ------------------------------------------ | ------------------------------------------------- |
| Alles in einem Commit speichern            | Kleine, logisch zusammenhÃ¤ngende Commits          |
| Ohne Branch direkt auf `main` entwickeln   | Immer Feature-Branches verwenden                  |
| Leere oder unverstÃ¤ndliche Commit-Messages | Klare, beschreibende Nachrichten                  |
| Keine Tags setzen                          | Wichtige Versionen taggen (`v1.0.0`, `v1.1.0`, â€¦) |


## Build- & Dependency Management

### 2.1.1 Begriff und Bedeutung von Build- und Dependency Management

Stellen Sie sich vor, Sie mÃ¶chten ein komplexes Gericht kochen: Sie benÃ¶tigen die richtigen Zutaten (AbhÃ¤ngigkeiten) und ein Rezept, das die einzelnen Schritte (Build-Prozess) beschreibt. In der Softwareentwicklung Ã¼bernehmen Build- und Dependency-Management-Tools genau diese Aufgaben â€“ sie sorgen dafÃ¼r, dass alle benÃ¶tigten Komponenten vorhanden sind und das Projekt korrekt zusammengesetzt wird.

**Definition:**  
 - `Build-Management` bezeichnet den automatisierten Prozess, bei dem Quellcode, Ressourcen und AbhÃ¤ngigkeiten zu einer lauffÃ¤higen Software zusammengefÃ¼hrt werden. 
 - `Dependency Management` sorgt dafÃ¼r, dass alle externen Bibliotheken und Module in der richtigen Version verfÃ¼gbar sind.

**Zweck:**  
- Automatisierung der Erstellung von Softwarepaketen
- Sicherstellung, dass alle benÃ¶tigten Bibliotheken und Tools vorhanden sind
- Vermeidung von Versionskonflikten und manuellen Fehlern
- Erleichterung der Zusammenarbeit im Team

**Komponenten:**  
- **Build-Tool:** FÃ¼hrt die einzelnen Schritte des Build-Prozesses aus (z. B. Kompilieren, Testen, Paketieren)
- **Dependency-Manager:** Verwalten externe Bibliotheken und deren Versionen (z. B. Maven, Gradle, npm)
- **Konfigurationsdateien:** Beschreiben, welche AbhÃ¤ngigkeiten und Build-Schritte benÃ¶tigt werden (z. B. `pom.xml`, `build.gradle`, `package.json`)

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**  
> Build- und Dependency-Management sind das â€žRezeptbuchâ€œ und die â€žEinkaufslisteâ€œ der Softwareentwicklung â€“ sie sorgen fÃ¼r einen reibungslosen Ablauf und die richtige Zusammensetzung aller Teile.

***
Quellen


***

### 2.1.2 Tools: Ant, Maven, Gradle

Die Automatisierung des Build-Prozesses ist eine zentrale Aufgabe in modernen Softwareprojekten. Sie ermÃ¶glicht reproduzierbare Ergebnisse, reduziert manuelle Fehler und beschleunigt die Entwicklung. Drei Werkzeuge haben sich dabei besonders etabliert: **Apache Ant**, **Apache Maven** und **Gradle**.
Alle drei dienen dem gleichen Ziel â€“ der Steuerung des Build- und Dependency-Managements â€“ unterscheiden sich aber deutlich in Funktionsweise, Philosophie und Einsatzszenarien.

#### ðŸ§± **Apache Ant â€“ Das klassische Build-Tool**

**Ant** (Another Neat Tool) war eines der ersten weit verbreiteten Build-Werkzeuge fÃ¼r Java-Projekte.
Es basiert auf **XML-Skripten**, in denen die einzelnen Schritte des Build-Prozesses explizit beschrieben werden â€“ vergleichbar mit einem **Skript, das jeden Befehl einzeln vorgibt**.

**FunktionalitÃ¤t:**

* Aufgabenbasiert: Der Build besteht aus *Targets* (z. B. `compile`, `jar`, `test`)
* Keine Standardstruktur: Entwickler mÃ¼ssen alle Pfade, Ziele und AbhÃ¤ngigkeiten manuell angeben
* Erweiterbar durch eigene Tasks oder externe Bibliotheken

**Verwendungsbereich:**

* Kleinere bis mittlere Projekte mit klar definierten AblÃ¤ufen
* Legacy-Systeme oder Umgebungen mit spezifischen Build-Schritten

**Besonderheiten:**

* Hohe FlexibilitÃ¤t, aber auch viel Konfigurationsaufwand
* Keine native Dependency-Verwaltung (oft in Kombination mit Ivy verwendet)

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Ant ist wie ein manuelles Kochrezept â€“ prÃ¤zise, aber jede Zutat und jeder Schritt mÃ¼ssen einzeln angegeben werden.

---

#### âš™ï¸ **Apache Maven â€“ Standardisierung und Wiederverwendbarkeit**

**Maven** wurde als Antwort auf die KomplexitÃ¤t von Ant entwickelt und fÃ¼hrte den Ansatz des **â€žConvention over Configurationâ€œ** ein.
Statt alle Schritte manuell zu beschreiben, nutzt Maven **vordefinierte Projektstrukturen und Lebenszyklen**.

**FunktionalitÃ¤t:**

* Standardisierter Build-Lifecycle (`compile`, `test`, `package`, `install`, `deploy`)
* Zentrale Konfigurationsdatei `pom.xml` (Project Object Model)
* Integriertes **Dependency Management** Ã¼ber zentrale Repositories (z. B. Maven Central)
* Plugin-basiertes System zur Erweiterung

**Verwendungsbereich:**

* MittelgroÃŸe bis groÃŸe Projekte mit mehreren Modulen
* Unternehmen mit standardisierten Build-Prozessen und klaren Release-Strukturen

**Besonderheiten:**

* Stark konventionsgetrieben â€“ funktioniert â€žout of the boxâ€œ, wenn man sich an Standards hÃ¤lt
* Weniger flexibel bei untypischen Projektstrukturen
* Sehr gute Integration in CI/CD-Umgebungen

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Maven ist wie ein Baukastensystem â€“ wer sich an die Regeln hÃ¤lt, erhÃ¤lt schnell ein funktionierendes, wartbares Ergebnis.

---

#### ðŸš€ **Gradle â€“ Modern, performant und flexibel**

**Gradle** kombiniert die StÃ¤rken von Ant (FlexibilitÃ¤t) und Maven (Konventionen) und gilt heute als **modernster Standard** fÃ¼r Build- und Dependency-Management â€“ insbesondere im **Java-, Android- und Kotlin-Umfeld**.

**FunktionalitÃ¤t:**

* Build-Skripte in **Groovy oder Kotlin DSL** statt XML
* Inkrementelle Builds und Caching fÃ¼r hohe Performance
* UnterstÃ¼tzung mehrerer Sprachen (Java, C++, Python etc.)
* Kompatibel zu Maven-Repositories und Ant-Tasks

**Verwendungsbereich:**

* GroÃŸe, modulare oder mehrsprachige Projekte
* Android-Entwicklung (Standard-Build-System von Android Studio)

**Besonderheiten:**

* Sehr flexibel und erweiterbar
* Schnell durch inkrementelle Builds und parallele AusfÃ¼hrung
* Steilere Lernkurve durch DSL und mÃ¤chtige KonfigurationsmÃ¶glichkeiten

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Gradle vereint Freiheit und Geschwindigkeit â€“ es bietet die Kontrolle von Ant und die Automatisierung von Maven in einem modernen Gewand.

---

#### ðŸ” **Vergleichstabelle**

| Merkmal                   | **Ant**                         | **Maven**                  | **Gradle**                                 |
| ------------------------- | ------------------------------- | -------------------------- | ------------------------------------------ |
| **Build-Definition**      | XML-Skripte (imperativ)         | XML (deklarativ, POM)      | Groovy/Kotlin DSL (deklarativ + flexibel)  |
| **Dependency Management** | Kein integriertes (nur mit Ivy) | Integriert (Maven Central) | Integriert (kompatibel mit Maven Repos)    |
| **Projektstruktur**       | Beliebig                        | Standardisiert             | Standardisiert, aber anpassbar             |
| **Leistung**              | Langsam bei groÃŸen Projekten    | Solide, aber statisch      | Schnell durch inkrementelles Caching       |
| **Erweiterbarkeit**       | Eigene Tasks                    | Plugins                    | Plugins + DSL                              |
| **Typischer Einsatz**     | Alte/Legacy-Projekte            | Unternehmensprojekte       | Moderne, komplexe Projekte (z. B. Android) |
| **Lernaufwand**           | Hoch (viel Konfiguration)       | Mittel                     | Mittel bis hoch (DSL)                      |

---

#### ðŸ§© Fazit

Alle drei Tools erfÃ¼llen denselben Zweck â€“ **automatisiertes Bauen und Verwalten von Softwareprojekten** â€“ unterscheiden sich aber in Philosophie und Anwendung:

* **Ant** steht fÃ¼r maximale Kontrolle und manuelle Konfiguration.
* **Maven** bringt Ordnung und Wiederverwendbarkeit durch klare Konventionen.
* **Gradle** bietet die modernste, performante und flexible LÃ¶sung fÃ¼r heterogene Projekte.

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> In modernen CI/CD-Pipelines wird Gradle zunehmend zum Standard, wÃ¤hrend Maven in Enterprise-Projekten dominiert und Ant vor allem zur Integration Ã¤lterer Systeme eingesetzt wird.

---

**Quellen**

* [Apache Ant Project](https://ant.apache.org/)
* [Apache Maven Project](https://maven.apache.org/)
* [Gradle Build Tool Documentation](https://docs.gradle.org/)
* [Android Developers: Configure your build](https://developer.android.com/studio/build)

---

Perfekt âœ… â€” das ist eine sehr gute Kombination. Dann formuliere ich den Abschnitt so, dass er:

* **didaktisch** erklÃ¤rt, *was* ein Dependency Graph ist und *warum* er wichtig ist,
* **praktisch** zeigt, *wie* man ihn mit realen Tools (z. B. Maven / Gradle) erzeugt und interpretiert,
* und mit einem **grafischen Beispiel (Mermaid-Diagramm)** illustriert, wie AbhÃ¤ngigkeiten strukturiert sind.

---

### 2.1.3 Dependency Graph â€“ AbhÃ¤ngigkeiten sichtbar machen

In modernen Softwareprojekten besteht eine Anwendung selten nur aus eigenem Code. Sie greift auf unzÃ¤hlige externe Bibliotheken zurÃ¼ck â€“ Frameworks, Logging-Systeme, Datenbanktreiber oder Testtools. Diese wiederum bringen **eigene AbhÃ¤ngigkeiten** mit, wodurch ein komplexes Netz entsteht: den **Dependency Graph**.

#### ðŸ§© Was ist ein Dependency Graph?

Ein **Dependency Graph** (AbhÃ¤ngigkeitsgraph) stellt die **Beziehungen zwischen Modulen und Bibliotheken** in einem Projekt **visuell oder hierarchisch** dar.
Jede Kante zeigt, dass ein Modul ein anderes benÃ¶tigt, um lauffÃ¤hig zu sein.

**Beispielhafte Darstellung:**

```mermaid
graph TD
    A[Projekt-Core] --> B[Spring Boot]
    B --> C[Spring Context]
    B --> D[Spring Web]
    D --> E[Jackson Databind]
    D --> F[Tomcat Server]
    A --> G[JUnit]
    G --> H[Hamcrest]
```

*Dieses Diagramm zeigt den typischen Aufbau eines Java-Projekts mit Spring Boot. Man erkennt, wie sich zentrale AbhÃ¤ngigkeiten (z. B. `spring-boot-starter-web`) in weitere UnterabhÃ¤ngigkeiten verzweigen.*

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> Der Dependency Graph ist die â€žLandkarteâ€œ eines Softwareprojekts â€“ er zeigt, wovon das System abhÃ¤ngt und welche Komponenten indirekt eingebunden werden.

---

#### âš™ï¸ Wozu dient ein Dependency Graph?

| Zweck                  | Beschreibung                                                                                           |
| ---------------------- | ------------------------------------------------------------------------------------------------------ |
| **Transparenz**        | Zeigt, welche Bibliotheken direkt und indirekt verwendet werden.                                       |
| **Fehleranalyse**      | Hilft, Konflikte (â€žDependency Hellâ€œ) zu erkennen â€“ etwa doppelte oder inkompatible Versionen.          |
| **SicherheitsprÃ¼fung** | Identifiziert veraltete oder unsichere AbhÃ¤ngigkeiten.                                                 |
| **Optimierung**        | Erkennt unnÃ¶tige oder doppelt eingebundene Bibliotheken, die den Build verlangsamen.                   |
| **CI-Integration**     | Wird in CI/CD-Pipelines genutzt, um Builds automatisch auf Sicherheits- oder Lizenzprobleme zu prÃ¼fen. |

---

#### ðŸ§  Aufbau und Interpretation

Ein Dependency Graph unterscheidet typischerweise zwischen:

* **Direkten AbhÃ¤ngigkeiten** â€“ explizit im Projekt definiert (z. B. in `pom.xml` oder `build.gradle`)
* **Transitive AbhÃ¤ngigkeiten** â€“ indirekt Ã¼ber andere Bibliotheken eingebunden

**Beispiel:**
Ein Projekt hÃ¤ngt direkt von *Spring Boot* ab â†’ Spring Boot benÃ¶tigt *Spring Core* â†’ Spring Core benÃ¶tigt *Commons Logging*.
Das bedeutet: *Commons Logging* ist eine **transitive AbhÃ¤ngigkeit**.

---

#### ðŸ§° Praktische Erstellung mit gÃ¤ngigen Tools

| Tool       | Befehl / Methode           | Beschreibung                                                         |
| ---------- | -------------------------- | -------------------------------------------------------------------- |
| **Maven**  | `mvn dependency:tree`      | Zeigt alle direkten und transitiven AbhÃ¤ngigkeiten in Baumform.      |
| **Gradle** | `gradle dependencies`      | Listet AbhÃ¤ngigkeiten je Konfiguration (compile, runtime, test) auf. |
| **Ant**    | Mit Ivy (`ant ivy:report`) | Generiert HTML-Berichte Ã¼ber AbhÃ¤ngigkeiten.                         |

**Beispiel (Maven-Ausgabe):**

```
[INFO] --- maven-dependency-plugin:3.3.0:tree ---
com.example:projekt-core:jar:1.0.0
+- org.springframework.boot:spring-boot-starter-web:jar:3.2.0:compile
|  +- org.springframework.boot:spring-boot-starter-json:jar:3.2.0:compile
|  |  \- com.fasterxml.jackson.core:jackson-databind:jar:2.15.0:compile
+- org.junit.jupiter:junit-jupiter-api:jar:5.9.3:test
```

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> In Continuous-Integration-Umgebungen (z. B. Jenkins, GitHub Actions) kann dieser Befehl automatisiert ausgefÃ¼hrt werden, um Ã„nderungen an der AbhÃ¤ngigkeitsstruktur zu prÃ¼fen und Sicherheits-Alerts auszugeben.

---

#### ðŸš¦ Typische Probleme und Best Practices

| Problem                     | Ursache                                | LÃ¶sung                                                                 |
| --------------------------- | -------------------------------------- | ---------------------------------------------------------------------- |
| **Dependency Hell**         | Mehrere Versionen derselben Bibliothek | Versionskonflikte explizit in `pom.xml` oder `build.gradle` definieren |
| **SicherheitslÃ¼cken**       | Veraltete AbhÃ¤ngigkeiten               | Automatisierte PrÃ¼fung (z. B. `OWASP Dependency Check`, `Snyk`)        |
| **Zu viele AbhÃ¤ngigkeiten** | UnnÃ¶tige Bibliotheken eingebunden      | Refactoring: Nur tatsÃ¤chlich benÃ¶tigte Module deklarieren              |
| **Fehlende Transparenz**    | Keine regelmÃ¤ÃŸige Analyse              | CI-Job einrichten, der bei Ã„nderungen Dependency-Bericht generiert     |

---

#### ðŸ§­ Fazit

Ein klarer Ãœberblick Ã¼ber ProjektabhÃ¤ngigkeiten ist essenziell fÃ¼r **StabilitÃ¤t, Sicherheit und Wartbarkeit**.
Der Dependency Graph hilft Entwickler:innen, Risiken frÃ¼hzeitig zu erkennen und die QualitÃ¤t des Builds zu sichern.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> Wer seine AbhÃ¤ngigkeiten kennt, kontrolliert sein Projekt â€“ nicht umgekehrt.

---

**Quellen**

* [Maven Dependency Plugin](https://maven.apache.org/plugins/maven-dependency-plugin/)
* [Gradle Dependencies Task](https://docs.gradle.org/current/userguide/viewing_debugging_dependencies.html)
* [OWASP Dependency Check](https://owasp.org/www-project-dependency-check/)
* [Apache Ivy](https://ant.apache.org/ivy/)

---

## Continuous Integration (CI)

In modernen Softwareprojekten ist es entscheidend, CodeÃ¤nderungen regelmÃ¤ÃŸig, automatisiert und Ã¼berprÃ¼fbar zu integrieren. Genau das ermÃ¶glicht **Continuous Integration (CI)**: ein Prozess, der sicherstellt, dass neue Codeversionen nahtlos in das bestehende System eingebunden werden â€“ **frÃ¼hzeitig, automatisch und fehlerresistent**.

### Begriff und Konzept

**Continuous Integration (CI)** bezeichnet eine **praktische und methodische Vorgehensweise** in der Softwareentwicklung, bei der CodeÃ¤nderungen **kontinuierlich** (mehrmals tÃ¤glich) in ein zentrales Repository integriert und automatisch getestet werden.

**Ziel:**

* FrÃ¼herkennung von Integrationsproblemen
* Sicherstellung der SoftwarequalitÃ¤t
* Schnelle RÃ¼ckmeldung (Feedback) an Entwickler:innen

**Prinzipien:**

1. Gemeinsamer Code-Bestand (zentrales Repository, z. B. GitHub, GitLab)
2. HÃ¤ufige Commits â€“ kleine Ã„nderungen statt seltener, groÃŸer Updates
3. Automatisierte Builds und Tests nach jeder Integration
4. Sofortiges Feedback bei Fehlern
5. Reproduzierbare, Ã¼berprÃ¼fbare Artefakte (z. B. Pakete, Container)

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> CI erkennt Fehler dort, wo sie entstehen â€“ direkt nach jeder CodeÃ¤nderung.


### Funktionsweise einer CI-Pipeline

Eine **CI-Pipeline** ist eine automatisierte Abfolge von Schritten, die bei jeder Ã„nderung im Repository ausgefÃ¼hrt wird.

```mermaid
flowchart LR
    A[Commit im Git-Repository] --> B[Build-Prozess starten]
    B --> C[Code kompilieren]
    C --> D[Unit-Tests ausfÃ¼hren]
    D --> E[Codeanalyse & QualitÃ¤tssicherung]
    E --> F[Artefakt erzeugen z. B. JAR, Docker-Image]
    F --> G[Feedback an Entwickler]
```

**Typische Pipeline-Schritte:**

1. **Trigger:** Ein neuer Commit oder Pull Request startet den Prozess
2. **Build:** Quellcode wird kompiliert, AbhÃ¤ngigkeiten werden geladen
3. **Test:** Automatisierte Tests prÃ¼fen FunktionalitÃ¤t und StabilitÃ¤t
4. **Analyse:** CodequalitÃ¤t, SicherheitsprÃ¼fungen, Stilregeln
5. **Deploy (optional):** Bereitstellung in Test- oder Produktionsumgebung
6. **Feedback:** Ergebnis wird dem Entwickler-Team gemeldet

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> CI ist die Basis fÃ¼r *Continuous Delivery (CD)* und *Continuous Deployment* â€“ die Prozesse, die nach erfolgreichem Build die Software automatisch bereitstellen.

---

### Aufbau einer CI-Umgebung

Eine typische CI-Umgebung besteht aus mehreren Komponenten:

| Komponente                    | Aufgabe                                                                                            |
| ----------------------------- | -------------------------------------------------------------------------------------------------- |
| **Versionsverwaltungssystem** | Zentraler Speicherort des Quellcodes (z. B. Git, GitHub, GitLab)                                   |
| **Build-Server / CI-Server**  | FÃ¼hrt Builds und Tests automatisch aus (z. B. Jenkins, GitHub Actions, GitLab CI, Azure Pipelines) |
| **Build-Tools**               | Kompilieren den Code und verwalten AbhÃ¤ngigkeiten (z. B. Maven, Gradle, npm)                       |
| **Test-Frameworks**           | PrÃ¼fen FunktionalitÃ¤t (z. B. JUnit, Jest, PyTest)                                                  |
| **Artefakt-Repository**       | Speichert erzeugte Pakete fÃ¼r spÃ¤tere Deployments (z. B. Nexus, Artifactory)                       |

**Beispielhafte Architektur:**

```mermaid
graph TD
    Dev[Entwickler:in] -->|Commit| Repo[Git Repository]
    Repo -->|Trigger| CI[CI-Server z. B. Jenkins]
    CI -->|Build + Test| BT[Build-Tool -> Maven/Gradle]
    CI -->|Analyse| QA[Code Quality Tools -> SonarQube]
    CI -->|Artefakt speichern| AR[Artefakt-Repository]
    CI -->|Ergebnis| Dev
```

### Integration in Entwicklungsprozesse

**Continuous Integration** wirkt am effektivsten, wenn sie mit anderen Praktiken kombiniert wird:

| Methode                              | Beziehung zu CI                                | Nutzen                                        |
| ------------------------------------ | ---------------------------------------------- | --------------------------------------------- |
| **Git-Workflows**                    | CI wird bei jedem Commit oder Merge ausgefÃ¼hrt | FrÃ¼hzeitige Fehlererkennung                   |
| **Build-Management (Maven, Gradle)** | Automatisierte Builds und Tests                | Reproduzierbare Artefakte                     |
| **Code Review / Pull Requests**      | CI liefert objektive QualitÃ¤tsdaten            | Schnellere und fundiertere Entscheidungen     |
| **Continuous Delivery (CD)**         | Baut auf CI auf                                | Automatisierte Bereitstellung stabiler Builds |

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> CI ist kein isoliertes Tool, sondern ein zentraler Bestandteil moderner *DevOps*-Kultur â€“ sie verbindet Entwicklung, QualitÃ¤tssicherung und Betrieb.

---

### 3.6 Vorteile und Herausforderungen

| Vorteile                          | Herausforderungen                                 |
| --------------------------------- | ------------------------------------------------- |
| FrÃ¼herkennung von Fehlern         | Aufwendige Erstkonfiguration                      |
| Automatisierte QualitÃ¤tssicherung | Infrastruktur muss gepflegt werden                |
| Schnelleres Feedback              | Fehlalarme bei schlecht konfigurierten Tests      |
| Verbesserte Teamkommunikation     | Erfordert Disziplin und standardisierte Workflows |

> <span style="font-size: 1.5em">:bulb:</span> **Kernaussage:**
> Der Nutzen von CI steigt mit der QualitÃ¤t der Tests und der Konsequenz, mit der das Team den Prozess lebt.

---

### 3.7 Fazit

Continuous Integration ist heute **unverzichtbar** fÃ¼r professionelle Softwareentwicklung.
Sie schafft Transparenz, ZuverlÃ¤ssigkeit und Geschwindigkeit â€“ Grundpfeiler fÃ¼r agile und DevOps-orientierte Teams.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> CI ist nicht nur eine technische LÃ¶sung, sondern eine Kultur der Zusammenarbeit â€“ kleine Schritte, kontinuierlich geprÃ¼ft, kontinuierlich verbessert.

---

**Quellen**

* [Martin Fowler â€“ Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html)
* [Jenkins Documentation](https://www.jenkins.io/doc/)
* [GitHub Actions Documentation](https://docs.github.com/en/actions)
* [Atlassian: CI/CD-Guide](https://www.atlassian.com/continuous-delivery/continuous-integration)

---


## Entwicklungs-Workflows

Ein Entwicklungs-Workflow beschreibt, **wie** CodeÃ¤nderungen vom lokalen Rechner der Entwickler:innen **Ã¼ber Versionsverwaltung, Build- & Testschritte bis zur Ablage von Artefakten** flieÃŸen â€” idealerweise **automatisiert, reproduzierbar und transparent**. In diesem Kapitel zeigen wir den **Zusammenhang von Git, Build-System und CI**, anschlieÃŸend zwei **konkrete Umsetzungen** (GitHub Actions & Jenkins) und einen **direkten Vergleich**.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> Ein guter Workflow ist klar, automatisiert und messbar â€” und lÃ¤sst sich sowohl lokal als auch im CI-Server identisch ausfÃ¼hren.

### Zusammenspiel: Git â†” Build â†” CI

```mermaid
flowchart LR
    Dev[Entwickler:in] -->|Commit/PR| Git[Git-Repository]
    Git -->|Webhook/Trigger| CI[CI-System]
    CI -->|Build & Tests| BT[Build-Tool - Maven/Gradle]
    BT -->|Artefakte| Repo[Artefakt-Repository - Nexus/Artifactory]
    CI -->|Status & Berichte| PR[Pull Request]
```

**Ablauf in KÃ¼rze**

1. **Commit/PR:** Ã„nderungen werden in einem Branch gepusht und als Pull Request bereitgestellt.
2. **CI-Trigger:** CI startet automatisch (z. B. auf PR-Events).
3. **Build/Test:** Build-Tool (Maven/Gradle) kompiliert, testet und analysiert.
4. **Artefakt:** Optional entstehen Pakete/Docker-Images, die ins Artefakt-Repo geladen werden.
5. **Feedback:** Status (âœ…/âŒ), Testergebnisse, Metriken (z. B. CodequalitÃ¤t) erscheinen im PR.

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> Gleiche Kommandos lokal und im CI (z. B. `mvn clean verify`) vermeiden â€žworks on my machineâ€œ-Effekte.

### Workflow mit GitHub Actions (Cloud-basiert, repo-integriert)

**Ziel:** Bei jedem Push/PR wird gebaut, getestet und optional ein Release-Artefakt erzeugt.

**Voraussetzungen**

* Code liegt auf GitHub.
* Datei `.github/workflows/ci.yml`.
* Secrets (falls Artefakt-Repo/Registry genutzt wird).

**Beispiel: Java/Maven**

```yaml
name: CI (Maven)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Build & Test
        run: mvn -B clean verify

      - name: Upload Surefire Reports (Tests)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: target/surefire-reports/

  package:
    needs: build-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'
      - name: Package
        run: mvn -B -DskipTests package
      - name: Publish artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar
```

**Was passiert hier?**

* Trigger auf `push`/`pull_request` nach `main`.
* **Job 1:** baut & testet; Testberichte werden als Artefakt beigefÃ¼gt.
* **Job 2:** paketiert nur auf `main`-Push (Release-Ã¤hnlicher Build).

> <span style="font-size: 1.5em">:warning:</span> **Achtung:**
> Bei Multi-Module-Projekten auf korrekte Arbeitsverzeichnisse/Paths und Caching achten, um Laufzeiten niedrig zu halten.

### Workflow mit Jenkins (selbst gehostet, hochgradig erweiterbar)

**Ziel:** Gleicher Pipeline-Ablauf on-prem oder in der eigenen Infrastruktur.

**Voraussetzungen**

* Jenkins mit nÃ¶tigen Plugins (Git, Pipeline, ggf. JDK- und Maven-Tool-Installer).
* Jenkins-Credentials (z. B. fÃ¼r Artefakt-Repos).
* Multibranch-Pipeline oder klassischer Pipeline-Job.

**Beispiel: declarative `Jenkinsfile` (Java/Maven)**

```groovy
pipeline {
  agent any

  tools {
    jdk 'jdk-21'
    maven 'maven-3.9'
  }

  options {
    skipDefaultCheckout(true)
    timestamps()
  }

  triggers { pollSCM('* * * * *') } // oder GitHub/GitLab Webhook

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build & Test') {
      steps {
        sh 'mvn -B clean verify'
      }
      post {
        always {
          junit 'target/surefire-reports/*.xml'
        }
      }
    }

    stage('Package (main only)') {
      when {
        expression { return env.BRANCH_NAME == 'main' }
      }
      steps {
        sh 'mvn -B -DskipTests package'
        archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
      }
    }
  }

  post {
    success { echo 'Build erfolgreich.' }
    failure { echo 'Build fehlgeschlagen.' }
  }
}
```

**Was passiert hier?**

* Jenkins zieht den Code und fÃ¼hrt **identische Maven-Kommandos** wie lokal aus.
* Testresultate werden per `junit` verÃ¶ffentlicht, Artefakte archiviert.
* Die `when`-Klausel stellt sicher: Paketierung nur auf dem Default-Branch.

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:**
> FÃ¼r PR-PrÃ¼fungen bieten sich **Multibranch Pipelines** an; Jenkins entdeckt Branches/PRs automatisch und erstellt passende Jobs.

### Branching-Strategie & Regeln (fÃ¼r beide Systeme)

* **Feature-Branches** von `main`/`develop`.
* **Pull Requests** verpflichtend mit:

  * grÃ¼nem CI-Status,
  * Code-Review (mind. 1 Approval),
  * Status-Checks (z. B. Lint, Security Scan).
* **Release-Tags** (`v1.2.3`) triggern **Release-Pipelines** (Signieren, Upload, Changelog).

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:**
> Technik folgt Regeln: Ohne saubere Branching- und Merge-Policies verpufft der Nutzen einer guten CI/CD.

### GitHub Actions vs. Jenkins â€“ Vor-/Nachteile im Ãœberblick

| Kriterium                   | **GitHub Actions**                                 | **Jenkins**                                                |
| --------------------------- | -------------------------------------------------- | ---------------------------------------------------------- |
| **Betriebsmodell**          | SaaS (Cloud), eng in GitHub integriert             | Selbst gehostet (on-prem/Cloud), volle Kontrolle           |
| **Inbetriebnahme**          | Sehr schnell, YAML im Repo                         | Installation, Pflege, Backup nÃ¶tig                         |
| **Skalierung**              | GitHub-Runner (gehostet oder selbst-gehostet)      | Frei skalierbar Ã¼ber eigene Agent-Knoten                   |
| **Ã–kosystem/Integrationen** | Marketplace-Actions, ideal fÃ¼r GitHub              | Riesige Plugin-Landschaft, viele SCM/Tools                 |
| **Sicherheit/Compliance**   | GitHub-Sicherheitsfeatures, einfache Secrets       | Feingranular, aber Eigenverantwortung (Hardening, Updates) |
| **Kostentransparenz**       | Minutenkontingente/Tarife                          | Infrastrukturkosten + Maintenance                          |
| **Vendor-Lock-in**          | HÃ¶her (GitHub-Ã–kosystem)                           | Gering (offen, portabel)                                   |
| **KomplexitÃ¤t**             | Niedrig bis mittel                                 | Mittel bis hoch (insb. bei groÃŸen Setups)                  |
| **Typische EinsatzfÃ¤lle**   | Unterricht, kleine bis mittlere Teams, Open Source | Enterprise, gemischte SCM-Landschaften, strikte Compliance |

**Kurzfazit**

* **GitHub Actions**: schnell startklar, ideal fÃ¼r Teams in GitHub â€“ â€žbatteries includedâ€œ.
* **Jenkins**: maximale FlexibilitÃ¤t/SouverÃ¤nitÃ¤t â€” sinnvoll, wenn Infrastruktur- und Compliance-Kontrolle wichtig sind.

### Best Practices (fÃ¼r beide Welten)

* **Ein Kommando, Ã¼berall:** z. B. `mvn clean verify` oder `gradle build` lokal & im CI identisch.
* **Schnelle Pipelines:** Caching (z. B. Maven/Gradle Cache), parallele Jobs, selektive Trigger.
* **QualitÃ¤t frÃ¼h prÃ¼fen:** Unit-/Integrationstests, Linting, Security Scans (z. B. OWASP Dependency-Check).
* **Artefakte versionieren:** SemVer + Release-Tags; Artefakt-Repo nutzen.
* **â€žFail fastâ€œ & klare Feedback-Schleifen:** PR-Checks obligatorisch, aussagekrÃ¤ftige Logs/Reports.
* **Secrets sauber verwalten:** GitHub Secrets / Jenkins Credentials, Principle of Least Privilege.


### Fazit

Beide AnsÃ¤tze â€” **GitHub Actions** und **Jenkins** â€” liefern robuste CI-Workflows. Die Entscheidung hÃ¤ngt von **Betriebsform, Compliance-Anforderungen, TeamgrÃ¶ÃŸe und bestehender Tool-Landschaft** ab. Wichtig ist weniger das Tool als die **Konsistenz der Regeln und die QualitÃ¤t der Tests**.

> <span style="font-size: 1.5em">:bulb:</span> **Kernaussage:**
> WÃ¤hlt das System, das eurem Kontext entspricht â€” aber sorgt dafÃ¼r, dass Builds, Tests und Reviews **standardisiert** und **automatisiert** sind.




