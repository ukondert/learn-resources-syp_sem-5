# 3.2 Teststrategie: Qualität von innen nach außen sichern

Ein Feature ist erst dann wirklich "fertig", wenn seine Funktionalität durch automatisierte Tests nachgewiesen wurde. In einem Projekt, das auf der Clean Architecture basiert, folgt die Teststrategie den Schichten der Architektur von innen nach außen. Dies wird oft als **Testpyramide** visualisiert: Viele schnelle Unit-Tests bilden die Basis, weniger, aber umfassendere Integrationstests stehen in der Mitte, und ganz wenige, langsame End-to-End-Tests bilden die Spitze.

---

### 3.2.1. Unit-Tests: Die Geschäftslogik mit Mock-Objekten isolieren

Unit-Tests sind das Fundament der Testpyramide. Ihr Ziel ist es, eine kleine, logische Einheit (eine "Unit", z.B. eine einzelne Funktion oder Klasse) komplett isoliert von ihren Abhängigkeiten zu testen. In der Clean Architecture konzentrieren wir uns hier auf die innersten Schichten: **Entities** und vor allem die **Use Cases** (Services).

**Das Problem:** Unser `RegistrationService` hat eine Abhängigkeit zum `UserRepository`. Um den Service zu testen, müssten wir also eine Datenbankverbindung herstellen. Das wäre langsam, kompliziert und kein echter Unit-Test mehr, da wir den Service nicht mehr *isoliert* testen.

**Die Lösung: Test-Doubles (insbesondere Mocks)**
Wir ersetzen die echte Abhängigkeit (`UserRepository`) durch einen "Doppelgänger", ein sogenanntes **Mock-Objekt**. Dieses Objekt sieht von außen aus wie das Original (es implementiert dasselbe Interface), aber wir können sein Verhalten im Test vollständig kontrollieren.

Bibliotheken wie **Mockito** (für Java) oder das `mockito`-Package (für Dart) sind darauf spezialisiert, solche Mock-Objekte zur Laufzeit für uns zu erstellen.

---

#### Der Arrange-Act-Assert (AAA) Zyklus mit Mockito

Ein gut strukturierter Unit-Test folgt immer dem AAA-Muster. Sehen wir uns das am Beispiel des `RegistrationService` an.

**Szenario:** Wir wollen testen, ob bei einer erfolgreichen Registrierung die `save`-Methode des `UserRepository` genau einmal aufgerufen wird.

##### 1. Arrange (Vorbereiten)

In dieser Phase bauen wir die Testumgebung auf. Wir erstellen das zu testende Objekt und seine gemockten Abhängigkeiten.

*   **Erstelle das Mock-Objekt:** Wir weisen Mockito an, ein Mock für das `UserRepository`-Interface zu erstellen.
*   **Erstelle das Testobjekt:** Wir instanziieren unseren `RegistrationService` und übergeben ihm das Mock-Repository.
*   **Konfiguriere das Mock (Stubbing):** Wir legen fest, wie sich das Mock verhalten soll. Wir sagen ihm: "Wenn deine `findByEmail`-Methode mit einer beliebigen E-Mail aufgerufen wird, gib `null` zurück (simuliert, dass der Benutzer noch nicht existiert)."

```dart
// ARRANGE
// 1. Mock-Objekt erstellen
final mockUserRepository = MockUserRepository(); 
// 2. Zu testendes Objekt mit dem Mock instanziieren
final registrationService = RegistrationService(mockUserRepository);
// 3. Verhalten des Mocks definieren (Stubbing)
when(mockUserRepository.findByEmail(any)).thenReturn(null);
```

##### 2. Act (Handeln)

In dieser Phase führen wir die Methode aus, die wir testen wollen.

*   **Rufe die Methode auf:** Wir rufen `registerUser` auf dem `registrationService` mit Testdaten auf.

```dart
// ACT
await registrationService.registerUser('test@example.com', 'password123');
```

##### 3. Assert (Überprüfen)

In dieser Phase überprüfen wir, ob das Ergebnis korrekt ist. Bei Unit-Tests mit Mocks gibt es zwei Arten von Überprüfungen:

*   **State Verification:** Prüfen, ob der Zustand des Systems korrekt ist (z.B. ob die Methode einen bestimmten Wert zurückgibt oder einen Fehler wirft).
*   **Behavior Verification:** Prüfen, ob die Interaktion mit den Abhängigkeiten (den Mocks) wie erwartet stattgefunden hat.

Wir nutzen Mockito, um das Verhalten zu verifizieren: "Überprüfe, ob die `save`-Methode auf unserem `mockUserRepository` genau einmal aufgerufen wurde."

```java
// ASSERT
// Überprüfe, ob die save-Methode 1x mit einem User-Objekt aufgerufen wurde
verify(mockUserRepository.save(any)).called(1);
```

> <span style="font-size: 1.5em">:mag:</span> **Zusammenfassend:** Mit Mocks können wir die Geschäftslogik unserer Use Cases testen, ohne uns um die Komplexität äußerer Schichten wie Datenbanken oder Netzwerkschnittstellen kümmern zu müssen. Wir simulieren die Außenwelt und konzentrieren uns voll und ganz auf die korrekte Funktion unserer Anwendungsregeln.

*   **Werkzeuge:** `test` & `mockito`-Package in Dart, JUnit & Mockito in Java, Jest in JavaScript.

---

### 3.2.2. Integrationstests: Das Zusammenspiel der Schichten

*   **Was wird getestet?** Das korrekte Zusammenspiel mehrerer Komponenten, typischerweise eine äußere mit einer inneren Schicht.
*   **Ziel:** Sicherstellen, dass die "Verträge" zwischen den Schichten funktionieren.
*   **Beispiel:**
    *   **Use Case + Repository:** Funktioniert der `RegistrationService` korrekt mit der *echten* `JpaUserRepository`-Implementierung? Wird ein Benutzer korrekt in einer Test-Datenbank gespeichert?
    *   **Controller + Use Case:** Wandelt der `AuthController` eine HTTP-Anfrage korrekt in einen Aufruf des `RegistrationService` um und gibt die richtige HTTP-Antwort zurück?
*   **Umsetzung:** Hier werden Teile der echten Infrastruktur verwendet, z.B. eine In-Memory-Datenbank (wie H2) oder ein Test-Webserver.

---

### 3.2.3. UI-Tests (Widget-Tests): Die Benutzeroberfläche

*   **Was wird getestet?** Die Komponenten der Benutzeroberfläche (UI).
*   **Ziel:** Überprüfen, ob die UI-Komponenten korrekt gerendert werden und auf Benutzereingaben (Klicks, Texteingaben) und Zustandsänderungen wie erwartet reagieren.
*   **Beispiel:**
    *   Wird eine Fehlermeldung angezeigt, wenn der Benutzer auf "Registrieren" klickt, ohne eine E-Mail eingegeben zu haben?
    *   Wird das Passwortfeld als "versteckt" (mit Sternchen) angezeigt?
*   **Werkzeuge:** `flutter_test` (für Widget-Tests) in Flutter, React Testing Library oder Cypress für Web-Anwendungen.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Testen Sie so weit "innen" und so isoliert wie möglich (Unit-Tests) und so weit "außen" und so integriert wie nötig (Integrations- & UI-Tests).
