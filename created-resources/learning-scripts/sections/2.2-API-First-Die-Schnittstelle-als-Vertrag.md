# 2.2. API-First: Die Schnittstelle als Vertrag

Stellen Sie sich erneut den Hausbau vor. Bevor der Elektriker die Kabel verlegt und der Installateur die Rohre, einigen sich alle auf einen detaillierten Plan: Wo genau sind die Steckdosen? Wo befinden sich die Wasseranschlüsse? Dieser Plan ist ein **verbindlicher Vertrag**, der sicherstellt, dass am Ende alles zusammenpasst.

In der Softwareentwicklung ist die **API (Application Programming Interface)** dieser Vertrag. Der **API-First-Ansatz** bedeutet, dass wir diesen Vertrag entwerfen, abstimmen und finalisieren, *bevor* wir mit der eigentlichen Programmierung von Frontend oder Backend beginnen.

## 2.2.1. Was bedeutet API-First? Ein allgemeinerer Blick auf Schnittstellen

API-First ist eine Entwicklungsstrategie, bei der die **Schnittstelle (API)** im Zentrum des gesamten Prozesses steht. Wichtig ist hierbei, den Begriff "API" weiter zu fassen: Es geht um *jeden* Vertrag zwischen zwei Software-Komponenten. Das kann eine Web-API sein, aber genauso gut ein **Java-Interface**, das den Vertrag zwischen zwei Modulen innerhalb derselben Anwendung definiert.

Anstatt eine Anwendung zu bauen und am Ende zu überlegen, wie die Teile miteinander kommunizieren, beginnen wir mit dem Design dieser Schnittstellen.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Beim "Interface-First"-Ansatz ist die Schnittstelle nicht ein nachträgliches Abfallprodukt der Implementierung, sondern das primäre Produkt, um das herum die Anwendung gebaut wird.

Dieser "Vertrag" definiert präzise, wie Komponenten interagieren.

**Beispiel 1: Der Vertrag einer REST-API (externe Kommunikation)**
Hier definiert der Vertrag, wie z.B. ein Frontend mit einem Backend spricht:
*   **Endpunkte:** Welche URLs stehen zur Verfügung (z.B. `/users`, `/products/{id}`)?
*   **Methoden:** Welche Aktionen sind möglich (GET, POST, PUT, DELETE)?
*   **Datenformate:** Wie sehen die Anfrage- und Antwort-Daten aus (z.B. JSON-Struktur)?
*   **Statuscodes:** Wie kommuniziert der Server Erfolg oder Fehler (z.B. `200 OK`, `404 Not Found`)?

**Beispiel 2: Der Vertrag eines Java-Interfaces (interne Kommunikation)**
Hier definiert der Vertrag, wie z.B. die Anwendungslogik (Use Case) mit der Datenbankschicht spricht, ohne sie direkt zu kennen (siehe Clean Architecture):
*   **Methodensignaturen:** Welche Operationen werden angeboten (z.B. `save(User user)`, `findById(long id)`)?
*   **Datenobjekte:** Welche Objekte werden übergeben und zurückgegeben (`User`, `Optional<User>`)?
*   **Exceptions:** Welche Fehler können auftreten (z.B. `UserNotFoundException`)?

In beiden Fällen gilt: Zuerst wird der Vertrag (die `openapi.yaml` oder das `UserRepository.java`-Interface) definiert, dann wird gegen diesen Vertrag entwickelt.

## 2.2.2. Vorteile für die Teamarbeit

Dieser Ansatz mag zunächst nach mehr Aufwand klingen, bietet aber entscheidende Vorteile, besonders in Teamprojekten.

*   **Parallele Entwicklung:** Sobald der API-Vertrag steht, können das **Frontend-Team** und das **Backend-Team** vollkommen unabhängig voneinander arbeiten.
    *   Das **Backend-Team** implementiert die im Vertrag definierte Logik.
    *   Das **Frontend-Team** entwickelt gegen einen **"Mock-Server"**, der simulierte, aber korrekt formatierte Antworten gemäß dem Vertrag zurückgibt. Das Warten auf das Backend entfällt.

*   **Klare Kommunikation & weniger Missverständnisse:** Die API-Definition ist die **einzige Quelle der Wahrheit** (`Single Source of Truth`). Diskussionen wie "Ich habe aber andere Daten erwartet!" gehören der Vergangenheit an.

*   **Frühes Feedback:** Die API kann frühzeitig mit anderen Teams oder sogar externen Partnern geteilt und validiert werden. Änderungen sind zu diesem Zeitpunkt noch "billig", da noch keine Zeile Implementierungscode geschrieben wurde.

*   **Bessere Qualität und Konsistenz:** Der Fokus liegt auf dem Design einer durchdachten und benutzerfreundlichen API. Dies führt zu konsistenten und wiederverwendbaren Schnittstellen.

> <span style="font-size: 1.5em">:warning:</span> **Achtung:** Der Erfolg des API-First-Ansatzes hängt von der Disziplin des Teams ab. Der einmal geschlossene "Vertrag" sollte während der Entwicklung nicht leichtfertig geändert werden. Änderungen müssen kommuniziert und abgestimmt werden.

## 2.2.3. Praktische Umsetzung: Driving Ports und Driven Ports

Je nachdem, ob wir eine Schnittstelle für die Außenwelt (z.B. ein Frontend) oder für die interne Kommunikation zwischen Modulen bereitstellen, unterscheidet sich die praktische Umsetzung des Vertrags. Hier kommen die Port-Bezeichnungen aus der Clean Architecture ins Spiel.

### Variante 1: Driving Port für externe Aufrufe (z.B. REST-API)

Ein **Driving Port** ist die API, die unser Anwendungskern der Außenwelt zur Verfügung stellt. Externe Akteure (wie ein Web-Controller) nutzen diesen Port, um die Anwendungslogik "anzutreiben". Für eine REST-API definieren wir diesen Vertrag mit der **OpenAPI-Spezifikation**.

```yaml
# openapi.yaml: Definiert den Vertrag für den Driving Port
openapi: 3.0.3
info:
  title: Semesterprojekt API
  version: 1.0.0
servers:
  - url: http://localhost:8080/api
paths:
  /users:
    get:
      summary: Gibt eine Liste aller Benutzer zurück
      tags:
        - Users
      operationId: listUsers
      responses:
        '200':
          description: Eine erfolgreiche Antwort mit einer Liste von Benutzern.
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
        '500':
          description: Interner Serverfehler
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

components:
  schemas:
    User:
      type: object
      required:
        - id
        - username
        - email
      properties:
        id:
          type: integer
          format: int64
          example: 10
          readOnly: true
        username:
          type: string
          example: 'max_mustermann'
        email:
          type: string
          format: email
          example: 'max.mustermann@example.com'

    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string
```

> <span style="font-size: 1.5em">:mag:</span> **Werkzeuge aus dem OpenAPI-Ökosystem:**
> *   **`Swagger Editor`**: Ein Online- oder lokaler Editor, der beim Schreiben der `YAML`-Datei hilft und sie in Echtzeit validiert.
> *   **`Swagger UI`**: Generiert automatisch eine interaktive, visuelle Dokumentation aus Ihrer `openapi.yaml`. Entwickler können die API direkt im Browser ausprobieren.
> *   **`Code-Generatoren`**: Erstellen automatisch Code-Grundgerüste (Server-Stubs, Client-SDKs) in verschiedenen Programmiersprachen basierend auf der API-Definition. Dies beschleunigt die Entwicklung enorm.

### Variante 2: Driven Port für interne Abhängigkeiten (z.B. Persistenz)

Ein **Driven Port** ist eine Schnittstelle, die der Anwendungskern *benötigt*, um mit externen Systemen (wie einer Datenbank) zu kommunizieren. Der Anwendungskern definiert den Port (das Interface), aber die Implementierung kommt von einer äußeren Schicht. Die Anwendungslogik wird also von dieser externen Implementierung "getrieben".

Für die Kommunikation *innerhalb* unserer Anwendung definieren wir diesen Vertrag mit einem **Java-Interface**.

```java
// Der "Vertrag" für den Driven Port (Persistenz)
// Ort: application/domain/port/UserRepository.java
package com.example.projekt.application.domain.port;

import com.example.projekt.application.domain.model.Benutzer;
import java.util.Optional;

/**
 * Dieser Driven Port definiert den Vertrag für die Persistenz von Benutzer-Objekten.
 * Der Anwendungskern gibt vor, welche Methoden er benötigt.
 * Die Infrastructure-Schicht liefert die konkrete Implementierung.
 */
public interface UserRepository {

    /**
     * Speichert einen neuen oder aktualisiert einen bestehenden Benutzer.
     * @param benutzer Der zu speichernde Benutzer.
     * @return Der gespeicherte Benutzer (ggf. mit generierter ID).
     */
    Benutzer save(Benutzer benutzer);

    /**
     * Findet einen Benutzer anhand seiner ID.
     * @param id Die ID des Benutzers.
     * @return Ein Optional, das den Benutzer enthält, wenn er gefunden wurde.
     */
    Optional<Benutzer> findById(long id);
}
```

**Vorteile dieses Ansatzes:**
*   **Entkopplung:** Die Anwendungslogik hängt nur vom `UserRepository`-Interface (dem Port) ab, nicht von einer konkreten Datenbankimplementierung.
*   **Testbarkeit:** Wir können für Tests eine einfache "Mock"-Implementierung des Interfaces erstellen, die ohne echte Datenbank funktioniert.
*   **Flexibilität:** Wir können die Datenbanktechnologie austauschen, indem wir einfach eine neue Klasse erstellen, die den `UserRepository`-Port implementiert, ohne die Anwendungslogik ändern zu müssen.

---

Für unser Projekt bedeutet das:
1.  **Driving Ports** (externe API) definieren wir mit **OpenAPI**.
2.  **Driven Ports** (interne Abhängigkeiten) definieren wir mit **Java-Interfaces**.
