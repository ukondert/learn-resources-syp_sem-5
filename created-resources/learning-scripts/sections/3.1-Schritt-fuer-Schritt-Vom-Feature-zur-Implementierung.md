# 3.1. Schritt-für-Schritt: Vom Feature zur Implementierung – Der vertikale Schnitt

In der agilen Entwicklung, insbesondere bei Ansätzen wie Scrumban, denken wir nicht in technischen Schichten (z.B. "zuerst die Datenbank, dann das Backend, dann das Frontend"), sondern in funktionalen "vertikalen Schnitten". Jede User Story repräsentiert einen solchen Schnitt – ein kleines, aber vollständiges Stück Funktionalität, das einen Mehrwert für den Endbenutzer liefert.

Stellen Sie es sich wie das Schneiden einer Torte vor: Anstatt Schicht für Schicht abzutragen (zuerst die Glasur, dann den Biskuit, dann die Füllung), schneiden wir ein komplettes Stück von oben nach unten heraus. Dieses Stück enthält alle Schichten und gibt uns einen Vorgeschmack auf das Gesamterlebnis.

**Warum dieser Ansatz?**

*   **Früher Mehrwert:** Nach jeder Iteration liefern wir eine funktionierende, testbare Funktion.
*   **Risikominimierung:** Technische Herausforderungen in allen Schichten werden frühzeitig erkannt.
*   **Fokus auf den Benutzer:** Das Team konzentriert sich auf die Lösung eines konkreten Benutzerproblems, nicht auf die Fertigstellung einer technischen Komponente.

---

## 3.1.1. Der rote Faden: Ein Feature vertikal umsetzen

Wir verfolgen eine beispielhafte User Story durch alle Phasen und Schichten unserer Architektur.

**User Story:** "Als neuer Benutzer möchte ich mich mit meiner E-Mail-Adresse und einem Passwort registrieren können, um Zugang zur Plattform zu erhalten."

### Phase 1: Planung und Design (Scrumban-Board & API)

1.  **User Story auf dem Board:** Die Anforderung wird als Karte auf dem Scrumban-Board (z.B. in GitHub Projects oder Trello) im `Backlog` angelegt. Das Team bespricht die Akzeptanzkriterien (z.B. "Passwort muss mindestens 8 Zeichen haben", "E-Mail muss eindeutig sein"). Wenn die Story klar ist, wird sie in die Spalte `Bereit zur Entwicklung` verschoben.

2.  **API-First – Der Vertrag:** Bevor eine Zeile Code geschrieben wird, definieren wir die Schnittstelle. Dies ist der "Vertrag" zwischen Frontend und Backend.
    *   **Aktion:** Das Team definiert den neuen API-Endpunkt in der `openapi.yaml`-Datei.
    *   **Beispiel (`openapi.yaml`):**
        ```yaml
        paths:
          /api/auth/register:
            post:
              summary: Registriert einen neuen Benutzer
              requestBody:
                required: true
                content:
                  application/json:
                    schema:
                      type: object
                      properties:
                        email:
                          type: string
                          format: email
                        password:
                          type: string
              responses:
                '201':
                  description: Benutzer erfolgreich erstellt
                '400':
                  description: Ungültige Eingabe (z.B. E-Mail existiert bereits)
        ```
    *   **Vorteil:** Frontend- und Backend-Entwickler können jetzt parallel arbeiten. Das Frontend-Team kann gegen einen "Mock-Server" (eine Simulation der API) entwickeln, während das Backend-Team die Logik implementiert.

### Phase 2: Backend-Implementierung (Clean Architecture)

Sobald die User Story `In Arbeit` ist, beginnt die Implementierung im Backend, streng nach den Regeln der Clean Architecture.

3.  **Controller (Frameworks & Drivers Schicht):** Der Controller ist der äußerste Punkt. Er empfängt den HTTP-Request und leitet die Daten an die nächste Schicht weiter.
    *   **Aktion:** Einen `AuthController` erstellen, der den `/api/auth/register`-Endpunkt bereitstellt. Er validiert die Eingabedaten und ruft den entsprechenden Use Case auf.

4.  **Use Case / Service (Application Business Rules Schicht):** Hier wohnt die Anwendungslogik.
    *   **Aktion:** Einen `RegistrationService` (oder `RegisterUserUseCase`) erstellen.
    *   **Logik:**
        *   Prüfen, ob die E-Mail-Adresse bereits existiert (indem das Repository befragt wird).
        *   Das Passwort sicher hashen (niemals im Klartext speichern!).
        *   Ein neues `User`-Objekt (aus der `Entities`-Schicht) erstellen.
        *   Das `User`-Objekt über das Repository-Interface speichern.

5.  **Repository-Interface (Application Business Rules Schicht):** Der Use Case kennt nur die Abstraktion des Datenzugriffs, nicht die konkrete Datenbank.
    *   **Aktion:** Ein `UserRepository`-Interface definieren mit Methoden wie `save(user)` und `findByEmail(email)`.

6.  **Repository-Implementierung (Frameworks & Drivers Schicht):** Die konkrete Implementierung des Interfaces, die mit der Datenbank spricht.
    *   **Aktion:** Eine `JpaUserRepository`-Klasse erstellen, die das `UserRepository`-Interface implementiert und z.B. Spring Data JPA verwendet, um die Daten in einer PostgreSQL-Datenbank zu speichern.

### Phase 3: Frontend-Implementierung

Parallel zur Backend-Entwicklung wird die Benutzeroberfläche erstellt.

7.  **UI-Komponente erstellen:**
    *   **Aktion:** Ein Registrierungsformular (z.B. als Flutter-Widget oder React-Komponente) mit Eingabefeldern für E-Mail und Passwort sowie einem "Registrieren"-Button erstellen.

8.  **API-Anbindung:**
    *   **Aktion:** Eine Funktion schreiben, die beim Klick auf den Button die im Formular eingegebenen Daten sammelt und einen `POST`-Request an den `/api/auth/register`-Endpunkt sendet (z.B. mit dem `http`-Package in Flutter oder `axios` in React).
    *   **Logik:** Die Anwendung muss auf die verschiedenen Antworten der API reagieren (z.B. bei Erfolg zum Login weiterleiten, bei einem Fehler eine Nachricht anzeigen).

### Phase 4: Abschluss und Review

9.  **Testing & Review:** Die fertige Funktion wird durch alle Schichten hindurch getestet (End-to-End-Test). Funktioniert der gesamte Ablauf von der UI-Eingabe bis zur Datenbankspeicherung? Code-Reviews stellen die Qualität sicher.

10. **Fertig:** Die User Story wird auf dem Board in die Spalte `Fertig` verschoben. Das Team hat ein wertvolles, funktionierendes Inkrement der Software geliefert.

---

## 3.1.2. Tipps für den Technologie-Stack

*   **Backend (Spring Boot):**
    *   **Datenbanken:** Verwenden Sie eine In-Memory-Datenbank wie **H2** für schnelle lokale Entwicklung und automatisierte Tests. Konfigurieren Sie Ihr Projekt so (z.B. mit Spring Profiles), dass Sie für die "echte" Anwendung einfach auf eine robuste Datenbank wie **PostgreSQL** oder **MySQL** umschalten können.
    *   **Sicherheit:** Nutzen Sie **Spring Security** für die Authentifizierung und das Passwort-Hashing. Es ist der Industriestandard und nimmt Ihnen viel komplexe Arbeit ab.

*   **Frontend (z.B. Flutter, React, Angular):**
    *   **State Management:** Trennen Sie die UI-Logik von der reinen Darstellung. Verwalten Sie den Anwendungszustand (z.B. ob ein Benutzer eingeloggt ist) mit bewährten State-Management-Bibliotheken (z.B. `Provider`/`Bloc` in Flutter, `Redux`/`Context API` in React).
    *   **API-Clients:** Erstellen Sie eine dedizierte Service-Klasse, die für die gesamte Kommunikation mit dem Backend zuständig ist. Das hält Ihren UI-Code sauber und macht die API-Aufrufe wiederverwendbar. Tools wie `axios` (für Web) oder `http`/`dio` (für Flutter) sind hierfür ideal.
